#! /usr/bin/env ruby
# Copyleft meh. [http://meh.doesntexist.org | meh@paranoici.org]
#
# This file is part of faildns.
#
# faildns is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# faildns is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with faildns. If not, see <http://www.gnu.org/licenses/>.

require 'faildns/server'
require 'faildns/client'
require 'optimus'
require 'rexml/document'

opt = Optimus.new {|o|
  o.set(
    :type => :numeric,

    :long  => 'port',
    :short => 'p',

    :default => 53
  )

  o.set(
    :type => :string,

    :long  => 'host',
    :short => 'h',

    :default => '0.0.0.0'
  )

  o.set(
    :type => :string,

    :long  => 'configuration',
    :short => 'c'
  )
}

$config = REXML::Document.new(File.new(opt.params[:c]))

$server = DNS::Server.new {|s|
    s.options[:host] = ($config.elements.each('//bind/host') {}.first.text rescue nil) || opt.params[:host]
    s.options[:port] = ($config.elements.each('//bind/port') {}.first.text rescue nil) || opt.params[:port]
}

$client = DNS::Client.new {|c|
  $config.elements.each('//servers/server') {|server|
    c.servers.push server.text
  }
}

$data = {}

$data[:options] = {
  :ttl => ($config.elements.each('//misc/ttl') {}.first.text.to_i rescue 3600)
}

class Domain
  class Cache
    class Record
      attr_reader :resource

      def initialize (resource)
        @modified = Time.now

        @resource = resource
      end

      def valid?
        puts @resource.name, (@modified.to_i + @resource.ttl), Time.now.to_i
        (@modified.to_i + @resource.ttl) > Time.now.to_i
      end
    end

    attr_accessor :ttl

    attr_reader :domain, :records

    def initialize (domain, records={}, exists=true)
      @domain  = domain
      @records = records
      @exists  = exists

      @ttl = $data[:options][:ttl]

      if block_given?
        yield self
      end
    end

    def [] (name)
      @records[name]
    end

    def []= (name, value)
      @records[name] = Record.new(value)
    end

    def update (resource)
      @modified = Time.now

      @records[resource.type.to_sym] = Record.new(resource)
    end

    def valid? (name=nil)
      if name
        @records[name].valid? rescue false
      else
        (@modified.to_i + @ttl) > Time.now.to_i
      end
    end

    def exists?;     @exists                               end
    def exists!;     @exists = true;  @modified = Time.now end
    def not_exists!; @exists = false; @modified = Time.now end
  end

  attr_accessor :type, :matches, :location, :ttl

  def initialize (*args)
    @type, @matches, @location, @ttl = *args

    if block_given?
      yield self
    end

    self.normalize
  end

  def match (domain)
    domain.to_s.match(@regexp)
  end

  def normalize
    case @type
      when 'regexp'
        @regexp = Regexp.new(@matches)

      else
        @regexp = Regexp.new('^' + Regexp.escape(@matches).gsub(/\\\*/, '.*').gsub(/\\\?/, '.') + '$')
    end
  end
end

$data[:cache]   = {}
$data[:domains] = []

$config.elements.each('//domains/domain') {|domain|
  $data[:domains].push Domain.new {|d|
    d.ttl      = (domain.attributes['ttl'] ? domain.attributes['ttl'].to_i : $data[:options][:ttl])
    d.type     = domain.attributes['type']
    d.matches  = domain.attributes['matches']
    d.location = domain.text.strip
  }
}
    
module Commands
  module IN
    def self.A (message)
      def self.resolve (name)
        if !$data[:cache][name]
          $data[:cache][name] = Domain::Cache.new(name)
        end

        if !$data[:cache][name].exists? && $data[:cache][name].valid?
          return
        end

        if $data[:cache][name].valid? :A
          return $data[:cache][name][:A].resource.data.to_s
        end

        ip = nil

        domain = $data[:domains].find {|domain|
          domain.match(name) && (DNS::IP.new(domain.location).version rescue 4) == 4
        } rescue nil

        if domain
          if !(DNS::IP.new(domain.location) rescue false) # if it's not an IP
            ip = resolve(domain.location)
          else
            ip = domain.ip
          end

          if ip
            $data[:cache][name].update DNS::ResourceRecord.new {|r|
              r.name  = name
              r.class = :IN
              r.type  = :A

              r.ttl = domain.ttl

              r.length = DNS::ResourceRecord::IN::A.length
              r.data   = DNS::ResourceRecord::IN::A.new(ip)
            }
          else
            $data[:cache][name].not_exists!
          end
        else
          response = $client.query(DNS::Question.new {|q|
            q.name = name

            q.class = :IN
            q.type  = :A
          }, { :limit => 1, :matches => [:NOERROR, :NXDOMAIN] }).first.last.message rescue nil

          if !response || response.header.status == :NXDOMAIN
            $data[:cache][name].not_exists!
            return
          else
            $data[:cache][name].exists!
          end

          answer = response.answers.find {|answer|
            answer.type == :A
          }

          if answer
            $data[:cache][name].update answer

            ip = answer.data.to_s
          end
        end

        return ip
      end

      question = message.questions.first

      ip = self.resolve(question.name.to_s)

      if !ip
        return DNS::Message.new(
          DNS::Header.new {|h|
            h.id = message.header.id
    
            h.type  = :RESPONSE
            h.class = :QUERY
    
            h.status = :NXDOMAIN
    
            h.questions = 1
          },
    
          [question]
        )
      end
    
      return DNS::Message.new(
        DNS::Header.new {|h|
          h.id = message.header.id
    
          h.type  = :RESPONSE
          h.class = :QUERY
    
          h.status = :NOERROR
    
          h.questions = 1
          h.answers   = 1
        },
    
        [question],
    
        [question].map {|question|
          DNS::ResourceRecord.new {|r|
            r.name  = question.name
            r.type  = :A
            r.class = :IN
    
            r.ttl = 3600
    
            r.length = DNS::ResourceRecord::IN::A.length
            r.data   = DNS::ResourceRecord::IN::A.new(ip)
          }
        }
      )
    end

    def self.AAAA (message)
      def self.resolve (name)
        if !$data[:cache][name]
          $data[:cache][name] = Domain::Cache.new(name)
        end

        if !$data[:cache][name].exists? && $data[:cache][name].valid?
          return
        end

        if $data[:cache][name].valid? :AAAA
          return $data[:cache][name][:AAAA].resource.data.to_s
        end

        ip = nil

        domain = $data[:domains].find {|domain|
          domain.match(name) && (DNS::IP.new(domain.location).version rescue 6) == 6
        } rescue nil

        if domain
          if !(DNS::IP.new(domain.location) rescue false) # if it's not an IP
            ip = resolve(domain.location)
          else
            ip = domain.ip
          end

          if ip
            $data[:cache][name].update DNS::ResourceRecord.new {|r|
              r.name  = name
              r.class = :IN
              r.type  = :AAAA

              r.ttl = domain.ttl

              r.length = DNS::ResourceRecord::IN::AAAA.length
              r.data   = DNS::ResourceRecord::IN::AAAA.new(ip)
            }
          else
            $data[:cache][name].not_exists!
          end
        else
          response = $client.query(DNS::Question.new {|q|
            q.name = name

            q.class = :IN
            q.type  = :AAAA
          }, { :limit => 1, :matches => [:NOERROR, :NXDOMAIN] }).first.last.message rescue nil

          if !response || response.header.status == :NXDOMAIN
            $data[:cache][name].not_exists!
            return
          else
            $data[:cache][name].exists!
          end

          answer = response.answers.find {|answer|
            answer.type == :AAAA
          }

          if answer
            $data[:cache][name].update answer

            ip = answer.data.to_s
          end
        end

        return ip
      end


      question = message.questions.first

      ip = self.resolve(question.name)

      if !ip
        return DNS::Message.new(
          DNS::Header.new {|h|
            h.id = message.header.id
    
            h.type  = :RESPONSE
            h.class = :QUERY
    
            h.status = :NXDOMAIN
    
            h.questions = 2
          },
    
          [question]
        )
      end
    
      return DNS::Message.new(
        DNS::Header.new {|h|
          h.id = message.header.id
    
          h.type  = :RESPONSE
          h.class = :QUERY
    
          h.status = :NOERROR
    
          h.questions = 1
          h.answers   = 1
        },
    
        [question],
    
        [question].map {|question|
          DNS::ResourceRecord.new {|r|
            r.name  = question.name
            r.type  = :AAAA
            r.class = :IN
    
            r.ttl = 3600
    
            r.length = DNS::ResourceRecord::IN::AAAA.length
            r.data   = DNS::ResourceRecord::IN::AAAA.new(ip)
          }
        }
      )
    end

  end
end

$server.register :input, lambda {|socket, message|
  question = message.questions.first
  method   = Commands.const_get(question.class.to_sym).method(question.type.to_sym) rescue nil

  if !method
    socket.send DNS::Message.new(
      DNS::Header.new {|h|
        h.id = message.header.id

        h.type  = :RESPONSE
        h.class = :QUERY

        h.status = :NOTIMP

        h.questions = 1
      },

      [question]
    )

    return
  end

  socket.send method.call(message)
}

$server.start
