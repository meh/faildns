#! /usr/bin/env ruby
# Copyleft meh. [http://meh.doesntexist.org | meh@paranoici.org]
#
# This file is part of faildns.
#
# faildns is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# faildns is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with faildns. If not, see <http://www.gnu.org/licenses/>.

require 'faildns/server'
require 'optimus'
require 'rexml/document'

opt = Optimus.new {|o|
  o.set(
    :type => :numeric,

    :long  => 'port',
    :short => 'p',

    :default => 53
  )

  o.set(
    :type => :string,

    :long  => 'configuration',
    :short => 'c'
  )
}

config = REXML::Document.new(File.new(opt.params[:c]))

options = opt.params

server = DNS::Server.new(options)

server.register :input, lambda {|socket, message|
  if message.questions.first.class != :IN && message.questions.first.type != :A
    return
  end

  ip = nil

  question = message.questions.first

  config.elements.each('//domain') {|domain|
    case domain.attributes['type']
      when 'regexp'
        if question.name.to_s.match(Regexp.new(domain.attributes['matches']))
          ip = domain.text
          break
        end

      else
        if question.name.to_s.match(Regexp.new('^' + Regexp.escape(domain.attributes['matches']).gsub(/\\\*/, '.*').gsub(/\\\?/, '.') + '$'))
          ip = domain.text
        end
    end
  }

  if !ip
    socket.send DNS::Message.new(
      DNS::Header.new {|h|
        h.id = message.header.id

        h.type  = :RESPONSE
        h.class = :QUERY

        h.status = :NXDOMAIN

        h.questions = 1
      },

      [question]
    )

    return
  end

  socket.send DNS::Message.new(
    DNS::Header.new {|h|
      h.id = message.header.id

      h.type  = :RESPONSE
      h.class = :QUERY

      h.status = :NOERROR

      h.questions = 1
      h.answers   = 1
    },

    [question],

    [question].map {|question|
      DNS::ResourceRecord.new {|r|
        r.name  = question.name
        r.type  = :A
        r.class = :IN

        r.ttl = 3600

        r.length = DNS::ResourceRecord::IN::A.length
        r.data   = DNS::ResourceRecord::IN::A.new(ip)
      }
    }
  )
}

server.start
