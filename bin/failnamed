#! /usr/bin/env ruby
# Copyleft meh. [http://meh.doesntexist.org | meh@paranoici.org]
#
# This file is part of faildns.
#
# faildns is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# faildns is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with faildns. If not, see <http://www.gnu.org/licenses/>.

require 'faildns/server'
require 'faildns/client'
require 'optimus'
require 'rexml/document'

opt = Optimus.new {|o|
  o.set(
    :type => :numeric,

    :long  => 'port',
    :short => 'p',

    :default => 53
  )

  o.set(
    :type => :string,

    :long  => 'host',
    :short => 'h',

    :default => '0.0.0.0'
  )

  o.set(
    :type => :string,

    :long  => 'configuration',
    :short => 'c'
  )
}

$config = REXML::Document.new(File.new(opt.params[:c]))

$server = DNS::Server.new {|s|
    s.options[:host] = ($config.elements.each('//bind/host') {}.first.text rescue nil) || opt.params[:host]
    s.options[:port] = ($config.elements.each('//bind/port') {}.first.text rescue nil) || opt.params[:port]
}

$client = DNS::Client.new {|c|
  $config.elements.each('//servers/server') {|server|
    c.servers.push server.text
  }
}

$options = {}

class Domain
  attr_accessor :type, :matches, :location

  def initialize
    if block_given?
      yield self
    end

    self.normalize
  end

  def match (domain)
    domain.to_s.match(@regexp)
  end

  def normalize
    case @type
      when 'regexp'
        @regexp = Regexp.new(@matches)

      else
        @regexp = Regexp.new('^' + Regexp.escape(@matches).gsub(/\\\*/, '.*').gsub(/\\\?/, '.') + '$')
    end
  end
end

$options[:domains] = []

$config.elements.each('//domains/domain') {|domain|
  $options[:domains].push Domain.new {|d|
    d.type     = domain.attributes['type']
    d.matches  = domain.attributes['matches']
    d.location = domain.text.strip
  }
}
    
module Commands
  module IN
    def self.A (message)
      question = message.questions.first

      ip = $options[:domains].find {|domain|
        domain.match(question.name)
      }.location rescue nil

      if !ip
        ip = $client.resolve(question.name)
      else
        # if it's not an IP but a domain, do magic
        if !(IPAddr.new(ip) rescue false)
          tmp = $options[:domains].find {|domain|
            domain.match(ip)
          }
          
          if !tmp
            ip = $client.resolve(ip)
          else
            ip = tmp.location
          end
        end
      end

      if !ip
        return DNS::Message.new(
          DNS::Header.new {|h|
            h.id = message.header.id
    
            h.type  = :RESPONSE
            h.class = :QUERY
    
            h.status = :NXDOMAIN
    
            h.questions = 1
          },
    
          [question]
        )
      end
    
      return DNS::Message.new(
        DNS::Header.new {|h|
          h.id = message.header.id
    
          h.type  = :RESPONSE
          h.class = :QUERY
    
          h.status = :NOERROR
    
          h.questions = 1
          h.answers   = 1
        },
    
        [question],
    
        [question].map {|question|
          DNS::ResourceRecord.new {|r|
            r.name  = question.name
            r.type  = :A
            r.class = :IN
    
            r.ttl = 3600
    
            r.length = DNS::ResourceRecord::IN::A.length
            r.data   = DNS::ResourceRecord::IN::A.new(ip)
          }
        }
      )
    end
  end
end

$server.register :input, lambda {|socket, message|
  question = message.questions.first
  method   = Commands.const_get(question.class.to_sym).method(question.type.to_sym) rescue nil

  if !method
    socket.send DNS::Message.new(
      DNS::Header.new {|h|
        h.id = message.header.id

        h.type  = :RESPONSE
        h.class = :QUERY

        h.status = :NOTIMP

        h.questions = 1
      },

      [question]
    )

    return
  end

  socket.send method.call(message)
}

$server.start
