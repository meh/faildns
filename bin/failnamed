#! /usr/bin/env ruby
# Copyleft meh. [http://meh.doesntexist.org | meh@paranoici.org]
#
# This file is part of faildns.
#
# faildns is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# faildns is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with faildns. If not, see <http://www.gnu.org/licenses/>.

require 'faildns/server'
require 'faildns/client'
require 'optimus'
require 'rexml/document'

opt = Optimus.new {|o|
  o.set(
    :type => :numeric,

    :long  => 'port',
    :short => 'p',

    :default => 53
  )

  o.set(
    :type => :string,

    :long  => 'host',
    :short => 'h',

    :default => '0.0.0.0'
  )

  o.set(
    :type => :string,

    :long  => 'configuration',
    :short => 'c'
  )
}

$config  = REXML::Document.new(File.new(opt.params[:c]))
$options = {
    :host => ($config.elements.each('//bind/host') {}.first.text rescue nil) || opt.params[:host],
    :port => ($config.elements.each('//bind/port') {}.first.text rescue nil) || opt.params[:port]
}
$server  = DNS::Server.new($options)

$client  = DNS::Client.new {|c|
  $config.elements.each('//servers/server') {|server|
    c.servers.push server.text
  }
}

module Commands
  module IN
    def self.A (message)
      question = message.questions.first

      ip = nil
      $config.elements.each('//domain') {|domain|
        case domain.attributes['type']
          when 'regexp'
            if question.name.to_s.match(Regexp.new(domain.attributes['matches']))
              ip = domain.text
              break
            end
    
          else
            if question.name.to_s.match(Regexp.new('^' + Regexp.escape(domain.attributes['matches']).gsub(/\\\*/, '.*').gsub(/\\\?/, '.') + '$'))
              ip = domain.text
            end
        end
      }
    
      ip = $client.resolve(question.name) if !ip

      if !ip
        return DNS::Message.new(
          DNS::Header.new {|h|
            h.id = message.header.id
    
            h.type  = :RESPONSE
            h.class = :QUERY
    
            h.status = :NXDOMAIN
    
            h.questions = 1
          },
    
          [question]
        )
      end
    
      return DNS::Message.new(
        DNS::Header.new {|h|
          h.id = message.header.id
    
          h.type  = :RESPONSE
          h.class = :QUERY
    
          h.status = :NOERROR
    
          h.questions = 1
          h.answers   = 1
        },
    
        [question],
    
        [question].map {|question|
          DNS::ResourceRecord.new {|r|
            r.name  = question.name
            r.type  = :A
            r.class = :IN
    
            r.ttl = 3600
    
            r.length = DNS::ResourceRecord::IN::A.length
            r.data   = DNS::ResourceRecord::IN::A.new(ip)
          }
        }
      )
    end
  end
end

$server.register :input, lambda {|socket, message|
  question = message.questions.first
  method   = Commands.const_get(question.class.to_sym).method(question.type.to_sym) rescue nil

  if !method
    socket.send DNS::Message.new(
      DNS::Header.new {|h|
        h.id = message.header.id

        h.type  = :RESPONSE
        h.class = :QUERY

        h.status = :NOTIMP

        h.questions = 1
      },

      [question]
    )

    return
  end

  socket.send method.call(message)
}

$server.start
